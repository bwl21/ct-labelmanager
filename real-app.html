<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChurchTools Label Manager - Real API</title>
    <style>
        :root {
          --ct-primary: #007cba;
          --ct-primary-hover: #0056b3;
          --ct-secondary: #6c757d;
          --ct-success: #28a745;
          --ct-danger: #dc3545;
          --ct-light: #f8f9fa;
          --ct-dark: #343a40;
          --ct-border-radius: 0.25rem;
          --ct-box-shadow-sm: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .ct-app { min-height: 100vh; background-color: var(--ct-light); }
        .ct-btn { display: inline-flex; align-items: center; justify-content: center; padding: 0.5rem 1rem; font-size: 0.875rem; font-weight: 500; border-radius: var(--ct-border-radius); border: 1px solid transparent; cursor: pointer; text-decoration: none; transition: all 0.2s ease; }
        .ct-btn:disabled { opacity: 0.65; cursor: not-allowed; }
        .ct-btn-primary { color: white; background-color: var(--ct-primary); border-color: var(--ct-primary); }
        .ct-btn-primary:hover:not(:disabled) { background-color: var(--ct-primary-hover); }
        .ct-btn-outline-primary { color: var(--ct-primary); border-color: var(--ct-primary); background-color: transparent; }
        .ct-btn-outline-primary:hover:not(:disabled) { color: white; background-color: var(--ct-primary); }
        .ct-btn-sm { padding: 0.25rem 0.75rem; font-size: 0.75rem; }
        .ct-btn-lg { padding: 0.75rem 1.5rem; font-size: 1rem; }
        .ct-btn-success { color: white; background-color: var(--ct-success); border-color: var(--ct-success); }
        .ct-btn-danger { color: white; background-color: var(--ct-danger); border-color: var(--ct-danger); }
        
        .ct-form-control { width: 100%; padding: 0.5rem 0.75rem; font-size: 0.875rem; border: 1px solid #ced4da; border-radius: var(--ct-border-radius); box-sizing: border-box; }
        .ct-form-control:focus { outline: none; border-color: var(--ct-primary); box-shadow: 0 0 0 2px rgba(0, 124, 186, 0.25); }
        .ct-form-label { display: block; font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; color: var(--ct-dark); }
        .ct-form-select { width: 100%; padding: 0.5rem 0.75rem; font-size: 0.875rem; border: 1px solid #ced4da; border-radius: var(--ct-border-radius); }
        
        .ct-card { background-color: white; border-radius: var(--ct-border-radius); border: 1px solid #e9ecef; box-shadow: var(--ct-box-shadow-sm); }
        .ct-card-header { padding: 1rem; border-bottom: 1px solid #e9ecef; background-color: #f8f9fa; border-radius: var(--ct-border-radius) var(--ct-border-radius) 0 0; }
        .ct-card-body { padding: 1rem; }
        
        .ct-table { width: 100%; font-size: 0.875rem; border-collapse: collapse; }
        .ct-table th, .ct-table td { padding: 0.75rem; border-bottom: 1px solid #dee2e6; text-align: left; }
        .ct-table th { font-weight: 600; background-color: #f8f9fa; }
        .ct-table tbody tr:hover { background-color: #f8f9fa; }
        
        .ct-alert { padding: 0.75rem 1rem; border-radius: var(--ct-border-radius); border: 1px solid transparent; margin-bottom: 1rem; }
        .ct-alert-info { color: #0c5460; background-color: #d1ecf1; border-color: #bee5eb; }
        .ct-alert-danger { color: #721c24; background-color: #f8d7da; border-color: #f5c6cb; }
        .ct-alert-success { color: #155724; background-color: #d4edda; border-color: #c3e6cb; }
        .ct-alert-warning { color: #856404; background-color: #fff3cd; border-color: #ffeaa7; }
        
        .ct-text-primary { color: var(--ct-primary); }
        .max-w-md { max-width: 28rem; }
        .max-w-7xl { max-width: 80rem; }
        .mx-auto { margin-left: auto; margin-right: auto; }
        .w-full { width: 100%; }
        .min-h-screen { min-height: 100vh; }
        .flex { display: flex; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-6 { padding-top: 1.5rem; padding-bottom: 1.5rem; }
        .h-16 { height: 4rem; }
        .space-y-4 > * + * { margin-top: 1rem; }
        .space-x-4 > * + * { margin-left: 1rem; }
        .text-lg { font-size: 1.125rem; }
        .text-xl { font-size: 1.25rem; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .font-semibold { font-weight: 600; }
        .text-gray-600 { color: #6b7280; }
        .text-gray-500 { color: #9ca3af; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-4 { margin-top: 1rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mr-2 { margin-right: 0.5rem; }
        .bg-white { background-color: white; }
        .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .border-b { border-bottom-width: 1px; }
        .border-gray-200 { border-color: #e5e7eb; }
        
        .ct-color-blue { background-color: #007cba; }
        .ct-color-green { background-color: #28a745; }
        .ct-color-red { background-color: #dc3545; }
        .ct-color-yellow { background-color: #ffc107; }
        .ct-color-orange { background-color: #fd7e14; }
        .ct-color-purple { background-color: #6f42c1; }
        .ct-color-pink { background-color: #e83e8c; }
        .ct-color-teal { background-color: #20c997; }
        .ct-color-cyan { background-color: #17a2b8; }
        .ct-color-gray { background-color: #6c757d; }
        .ct-color-dark { background-color: #343a40; }
        
        .color-dot { display: inline-block; width: 20px; height: 20px; border-radius: 50%; border: 1px solid #ddd; }
        
        .hidden { display: none; }
        .overflow-x-auto { overflow-x: auto; }
        .w-12 { width: 3rem; }
        .bg-blue-50 { background-color: #eff6ff; }
        .gap-4 > * + * { margin-left: 1rem; }
        .gap-2 > * + * { margin-left: 0.5rem; }
        .flex-wrap { flex-wrap: wrap; }
        .rounded { border-radius: 0.25rem; }
        
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--ct-primary);
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="app" class="ct-app min-h-screen">
        <!-- Header -->
        <header class="bg-white shadow-sm border-b border-gray-200">
            <div class="max-w-7xl mx-auto px-4">
                <div class="flex justify-between items-center h-16">
                    <h1 class="text-xl font-semibold ct-text-primary">ChurchTools Label Manager</h1>
                    <div v-if="isAuthenticated" class="flex items-center space-x-4">
                        <span class="text-sm text-gray-600">{{ currentUser }}</span>
                        <button @click="logout" class="ct-btn ct-btn-outline-primary ct-btn-sm">Logout</button>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="max-w-7xl mx-auto py-6 px-4">
            <!-- Login Form -->
            <div v-if="!isAuthenticated" class="max-w-md mx-auto">
                <div class="ct-card">
                    <div class="ct-card-header">
                        <h2 class="text-lg font-semibold">Login to ChurchTools</h2>
                        <p class="text-sm text-gray-600 mt-1">Enter your credentials to manage labels</p>
                    </div>
                    <div class="ct-card-body space-y-4">
                        <div>
                            <label class="ct-form-label">ChurchTools URL</label>
                            <input v-model="loginForm.baseUrl" type="url" class="ct-form-control" placeholder="https://your-church.church.tools">
                        </div>
                        <div>
                            <label class="ct-form-label">Username</label>
                            <input v-model="loginForm.username" type="text" class="ct-form-control" placeholder="Your username" @keyup.enter="login">
                        </div>
                        <div>
                            <label class="ct-form-label">Password</label>
                            <input v-model="loginForm.password" type="password" class="ct-form-control" placeholder="Your password" @keyup.enter="login">
                        </div>
                        <div v-if="loginError" class="ct-alert ct-alert-danger">
                            <strong>Error:</strong> {{ loginError }}
                        </div>
                        <div v-if="loginStatus" class="ct-alert ct-alert-info">
                            {{ loginStatus }}
                        </div>
                        <button @click="login" :disabled="isLoading" class="ct-btn ct-btn-primary w-full ct-btn-lg">
                            <span v-if="isLoading" class="spinner"></span>
                            {{ isLoading ? 'Logging in...' : 'Login to ChurchTools' }}
                        </button>
                    </div>
                </div>
            </div>

            <!-- Label Manager -->
            <div v-else>
                <!-- Controls -->
                <div class="flex justify-between items-center mb-4">
                    <div class="flex items-center space-x-4">
                        <h2 class="text-xl font-semibold">Label Manager</h2>
                        <select v-model="selectedType" @change="loadTags" class="ct-form-select" style="width: auto;">
                            <option value="persons">Person Tags</option>
                            <option value="songs">Song Tags</option>
                        </select>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button @click="loadTags" class="ct-btn ct-btn-outline-primary ct-btn-sm">
                            <span v-if="isLoadingTags" class="spinner"></span>
                            Refresh
                        </button>
                        <button @click="showCreateForm = true" class="ct-btn ct-btn-primary ct-btn-sm">Create Tag</button>
                    </div>
                </div>

                <!-- Bulk Operations -->
                <div class="ct-card mb-4">
                    <div class="ct-card-header">
                        <h3 class="font-semibold">🔧 Bulk Operations</h3>
                        <p class="text-sm text-gray-600 mt-1">{{ selectedTags.length }} tags selected</p>
                    </div>
                    <div class="ct-card-body">
                        <div class="flex flex-wrap items-center gap-4">
                            <div class="flex items-center gap-2">
                                <button @click="selectAll" class="ct-btn ct-btn-outline-primary ct-btn-sm">Select All</button>
                                <button @click="clearSelection" class="ct-btn ct-btn-outline-primary ct-btn-sm">Clear Selection</button>
                            </div>
                            
                            <div class="flex items-center gap-2">
                                <input 
                                    v-model="prefixFilter" 
                                    type="text" 
                                    placeholder="e.g., L:*" 
                                    class="ct-form-control" 
                                    style="width: 120px;"
                                >
                                <button @click="selectByPrefix" class="ct-btn ct-btn-outline-primary ct-btn-sm">Select by Prefix</button>
                            </div>
                            
                            <div class="flex items-center gap-2">
                                <select v-model="bulkColor" class="ct-form-select" style="width: auto;">
                                    <option value="">Select Color</option>
                                    <option value="blue">🔵 Blue</option>
                                    <option value="green">🟢 Green</option>
                                    <option value="red">🔴 Red</option>
                                    <option value="yellow">🟡 Yellow</option>
                                    <option value="orange">🟠 Orange</option>
                                    <option value="purple">🟣 Purple</option>
                                    <option value="pink">🩷 Pink</option>
                                    <option value="teal">🟦 Teal</option>
                                    <option value="cyan">🩵 Cyan</option>
                                    <option value="gray">⚫ Gray</option>
                                    <option value="dark">⚫ Dark</option>
                                </select>
                                <button @click="applyBulkColor" :disabled="!bulkColor || isBulkOperating" class="ct-btn ct-btn-success ct-btn-sm">
                                    <span v-if="isBulkOperating" class="spinner"></span>
                                    Apply Color
                                </button>
                            </div>
                            
                            <button @click="bulkDelete" :disabled="isBulkOperating" class="ct-btn ct-btn-danger ct-btn-sm">
                                <span v-if="isBulkOperating" class="spinner"></span>
                                Delete Selected
                            </button>
                        </div>
                        
                        <div v-if="bulkColor" class="mt-3 flex items-center gap-2">
                            <span class="text-sm text-gray-600">Preview color:</span>
                            <span :class="`color-dot ct-color-${bulkColor}`"></span>
                            <span class="text-sm font-medium">{{ bulkColor }}</span>
                        </div>
                        
                        <div v-if="bulkError" class="mt-3 ct-alert ct-alert-danger">{{ bulkError }}</div>
                        <div v-if="bulkSuccess" class="mt-3 ct-alert ct-alert-success">{{ bulkSuccess }}</div>
                    </div>
                </div>

                <!-- Create/Edit Form -->
                <div v-if="showCreateForm || editingTag" class="ct-card mb-4">
                    <div class="ct-card-header">
                        <h3 class="font-semibold">{{ editingTag ? 'Edit Tag' : 'Create New Tag' }}</h3>
                    </div>
                    <div class="ct-card-body space-y-4">
                        <div>
                            <label class="ct-form-label">Tag Name</label>
                            <input 
                                v-model="tagForm.name" 
                                type="text" 
                                class="ct-form-control" 
                                placeholder="Enter tag name (1-100 characters)"
                                maxlength="100"
                            >
                            <p class="text-xs text-gray-500 mt-1">{{ tagForm.name.length }}/100 characters</p>
                        </div>
                        <div>
                            <label class="ct-form-label">Description</label>
                            <input 
                                v-model="tagForm.description" 
                                type="text" 
                                class="ct-form-control" 
                                placeholder="Enter tag description (optional)"
                                maxlength="255"
                            >
                            <p class="text-xs text-gray-500 mt-1">{{ (tagForm.description || '').length }}/255 characters</p>
                        </div>
                        <div>
                            <label class="ct-form-label">Color</label>
                            <select v-model="tagForm.color" class="ct-form-select">
                                <option value="">Select a color</option>
                                <option value="blue">Blue</option>
                                <option value="green">Green</option>
                                <option value="red">Red</option>
                                <option value="yellow">Yellow</option>
                                <option value="orange">Orange</option>
                                <option value="purple">Purple</option>
                                <option value="pink">Pink</option>
                                <option value="teal">Teal</option>
                                <option value="cyan">Cyan</option>
                                <option value="gray">Gray</option>
                                <option value="dark">Dark</option>
                            </select>
                        </div>
                        <div v-if="tagError" class="ct-alert ct-alert-danger">{{ tagError }}</div>
                        <div class="flex space-x-2">
                            <button @click="saveTag" :disabled="isSaving" class="ct-btn ct-btn-primary">
                                <span v-if="isSaving" class="spinner"></span>
                                {{ editingTag ? 'Update' : 'Create' }}
                            </button>
                            <button @click="cancelEdit" class="ct-btn ct-btn-secondary">Cancel</button>
                        </div>
                    </div>
                </div>

                <!-- Tags Table -->
                <div class="ct-card">
                    <div class="ct-card-header">
                        <h3 class="font-semibold">{{ selectedType === 'persons' ? 'Person Tags' : 'Song Tags' }} ({{ tags.length }})</h3>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="ct-table">
                            <thead>
                                <tr>
                                    <th class="w-12">
                                        <input
                                            type="checkbox"
                                            :checked="allSelected"
                                            @change="toggleSelectAll"
                                            class="rounded"
                                        />
                                    </th>
                                    <th @click="sortBy('id')" style="cursor: pointer;">
                                        ID 
                                        <span v-if="sortField === 'id'">{{ sortDirection === 'asc' ? '↑' : '↓' }}</span>
                                    </th>
                                    <th @click="sortBy('name')" style="cursor: pointer;">
                                        Name 
                                        <span v-if="sortField === 'name'">{{ sortDirection === 'asc' ? '↑' : '↓' }}</span>
                                    </th>
                                    <th @click="sortBy('description')" style="cursor: pointer;">
                                        Description 
                                        <span v-if="sortField === 'description'">{{ sortDirection === 'asc' ? '↑' : '↓' }}</span>
                                    </th>
                                    <th @click="sortBy('color')" style="cursor: pointer;">
                                        Color 
                                        <span v-if="sortField === 'color'">{{ sortDirection === 'asc' ? '↑' : '↓' }}</span>
                                    </th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr v-for="tag in sortedTags" :key="tag.id" :class="{ 'bg-blue-50': selectedTags.includes(tag.id) }">
                                    <td>
                                        <input
                                            type="checkbox"
                                            :checked="selectedTags.includes(tag.id)"
                                            @change="toggleTagSelection(tag.id)"
                                            class="rounded"
                                        />
                                    </td>
                                    <td class="text-gray-500">{{ tag.id }}</td>
                                    <td class="font-semibold">{{ tag.name }}</td>
                                    <td class="text-sm text-gray-600">{{ tag.description || '-' }}</td>
                                    <td>
                                        <span v-if="tag.color" :class="`color-dot ct-color-${tag.color}`" :title="tag.color"></span>
                                        <span v-else class="text-gray-400">No color</span>
                                    </td>
                                    <td>
                                        <button @click="editTag(tag)" class="ct-btn ct-btn-outline-primary ct-btn-sm mr-2">Edit</button>
                                        <button @click="deleteTag(tag)" class="ct-btn ct-btn-danger ct-btn-sm">Delete</button>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                        <div v-if="isLoadingTags" class="ct-card-body text-center">
                            <span class="spinner"></span> Loading tags...
                        </div>
                        <div v-else-if="tags.length === 0" class="ct-card-body text-center text-gray-500">
                            No tags found. Create your first tag to get started.
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
        const { createApp, ref, reactive, computed, onMounted } = Vue;

        createApp({
            setup() {
                const isAuthenticated = ref(false);
                const currentUser = ref('');
                const isLoading = ref(false);
                const isLoadingTags = ref(false);
                const isSaving = ref(false);
                const loginError = ref('');
                const loginStatus = ref('');
                const tagError = ref('');
                const selectedType = ref('persons');
                const showCreateForm = ref(false);
                const editingTag = ref(null);
                const apiToken = ref('');
                const personId = ref(null);
                const selectedTags = ref([]);
                const prefixFilter = ref('');
                const bulkColor = ref('');
                const bulkError = ref('');
                const bulkSuccess = ref('');
                const isBulkOperating = ref(false);
                const sortField = ref('name');
                const sortDirection = ref('asc');
                
                const loginForm = reactive({
                    baseUrl: 'https://testbernhard.church.tools',
                    username: '',
                    password: ''
                });
                
                const tagForm = reactive({
                    name: '',
                    description: '',
                    color: ''
                });
                
                const tags = ref([]);
                
                const allSelected = computed(() => 
                    tags.value.length > 0 && selectedTags.value.length === tags.value.length
                );
                
                const sortedTags = computed(() => {
                    if (!tags.value.length) return [];
                    
                    return [...tags.value].sort((a, b) => {
                        let aVal = a[sortField.value];
                        let bVal = b[sortField.value];
                        
                        // Handle null/undefined values
                        if (aVal == null) aVal = '';
                        if (bVal == null) bVal = '';
                        
                        // Convert to string for comparison
                        aVal = String(aVal).toLowerCase();
                        bVal = String(bVal).toLowerCase();
                        
                        if (sortDirection.value === 'asc') {
                            return aVal.localeCompare(bVal);
                        } else {
                            return bVal.localeCompare(aVal);
                        }
                    });
                });
                
                // API Helper Functions
                const apiRequest = async (endpoint, options = {}) => {
                    const url = `${loginForm.baseUrl}/api${endpoint}`;
                    const headers = {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        ...options.headers
                    };

                    if (apiToken.value) {
                        headers['Authorization'] = `Login ${apiToken.value}`;
                    }

                    const response = await fetch(url, {
                        ...options,
                        headers,
                        credentials: 'include'
                    });

                    const responseText = await response.text();
                    let data;
                    
                    try {
                        data = JSON.parse(responseText);
                    } catch (e) {
                        console.error('Invalid JSON response:', responseText);
                        throw new Error('Invalid response from server');
                    }

                    if (!response.ok) {
                        const errorMessage = data.message || data.error || `HTTP ${response.status}: ${response.statusText}`;
                        console.error('API Error:', data);
                        throw new Error(errorMessage);
                    }

                    return data;
                };
                
                const login = async () => {
                    if (!loginForm.username || !loginForm.password) {
                        loginError.value = 'Please enter username and password';
                        return;
                    }
                    
                    isLoading.value = true;
                    loginError.value = '';
                    loginStatus.value = 'Connecting to ChurchTools...';
                    
                    try {
                        // Step 1: Login with credentials
                        loginStatus.value = 'Authenticating...';
                        const loginResponse = await fetch(`${loginForm.baseUrl}/api/login`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Accept': 'application/json',
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                username: loginForm.username,
                                password: loginForm.password
                            })
                        });

                        if (!loginResponse.ok) {
                            const errorData = await loginResponse.json().catch(() => ({}));
                            throw new Error(errorData.message || `Login failed: ${loginResponse.status} ${loginResponse.statusText}`);
                        }

                        const loginData = await loginResponse.json();
                        console.log('Login response:', loginData);

                        // Get person ID from response
                        const pId = loginData.data?.personId || loginData.personId;
                        if (!pId) {
                            console.error('No person ID in login response:', loginData);
                            throw new Error('Could not get person ID from login');
                        }

                        personId.value = pId;
                        console.log('Login successful, person ID:', pId);

                        // Step 2: Request login token
                        loginStatus.value = 'Getting authentication token...';
                        const tokenResponse = await fetch(`${loginForm.baseUrl}/api/persons/${pId}/logintoken`, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                            },
                            credentials: 'include'
                        });

                        if (!tokenResponse.ok) {
                            throw new Error(`Failed to get login token: ${tokenResponse.status} ${tokenResponse.statusText}`);
                        }

                        const tokenData = await tokenResponse.json();
                        console.log('Token response:', tokenData);

                        let token = null;
                        if (tokenData.data && typeof tokenData.data === 'string') {
                            token = tokenData.data;
                        } else if (tokenData.token) {
                            token = tokenData.token;
                        }

                        if (!token) {
                            console.error('No token in response:', tokenData);
                            throw new Error('No login token received');
                        }

                        // Store token and authenticate
                        apiToken.value = token;
                        currentUser.value = loginForm.username;
                        isAuthenticated.value = true;
                        
                        // Store in localStorage for persistence
                        localStorage.setItem('ct_login_token', token);
                        localStorage.setItem('ct_person_id', pId.toString());
                        localStorage.setItem('ct_base_url', loginForm.baseUrl);
                        localStorage.setItem('ct_username', loginForm.username);
                        
                        console.log('Authentication successful, login token received and stored');
                        
                        // Load initial tags
                        await loadTags();

                    } catch (error) {
                        console.error('Authentication error:', error);
                        loginError.value = error.message;
                        
                        // Check for CORS or network issues
                        if (error instanceof TypeError && error.message.includes('fetch')) {
                            loginError.value = 'Network error: Cannot connect to ChurchTools. Please check the URL and your internet connection.';
                        }
                    } finally {
                        isLoading.value = false;
                        loginStatus.value = '';
                    }
                };
                
                const logout = async () => {
                    try {
                        if (apiToken.value && personId.value) {
                            // Try to revoke the token on the server
                            await fetch(`${loginForm.baseUrl}/api/persons/${personId.value}/logintoken`, {
                                method: 'DELETE',
                                headers: {
                                    'Authorization': `Login ${apiToken.value}`,
                                    'Accept': 'application/json',
                                },
                                credentials: 'include'
                            });
                        }
                    } catch (error) {
                        console.error('Error revoking token:', error);
                    } finally {
                        // Always clear local state
                        isAuthenticated.value = false;
                        currentUser.value = '';
                        apiToken.value = '';
                        personId.value = null;
                        tags.value = [];
                        loginForm.username = '';
                        loginForm.password = '';
                        
                        // Clear localStorage
                        localStorage.removeItem('ct_login_token');
                        localStorage.removeItem('ct_person_id');
                        localStorage.removeItem('ct_base_url');
                        localStorage.removeItem('ct_username');
                    }
                };
                
                const loadTags = async () => {
                    if (!isAuthenticated.value) return;
                    
                    isLoadingTags.value = true;
                    selectedTags.value = []; // Clear selection when loading new tags
                    try {
                        const response = await apiRequest(`/tags?type=${selectedType.value}`);
                        tags.value = response.data || [];
                        console.log('Tags loaded:', tags.value);
                    } catch (error) {
                        console.error('Error loading tags:', error);
                        loginError.value = `Failed to load tags: ${error.message}`;
                    } finally {
                        isLoadingTags.value = false;
                    }
                };
                
                const editTag = (tag) => {
                    editingTag.value = tag;
                    tagForm.name = tag.name;
                    tagForm.description = tag.description || '';
                    tagForm.color = tag.color || '';
                    showCreateForm.value = false;
                };
                
                const saveTag = async () => {
                    const trimmedName = tagForm.name.trim();
                    
                    if (!trimmedName) {
                        tagError.value = 'Tag name is required';
                        return;
                    }
                    
                    if (trimmedName.length > 100) {
                        tagError.value = 'Tag name must be between 1 and 100 characters';
                        return;
                    }
                    
                    if (!tagForm.color) {
                        tagError.value = 'Tag color is required';
                        return;
                    }
                    
                    isSaving.value = true;
                    tagError.value = '';
                    
                    try {
                        const tagData = {
                            name: trimmedName,
                            description: tagForm.description.trim() || '',
                            color: tagForm.color
                        };
                        
                        if (editingTag.value) {
                            // Update existing tag
                            await apiRequest(`/tags/${editingTag.value.id}?type=${selectedType.value}`, {
                                method: 'PUT',
                                body: JSON.stringify(tagData)
                            });
                        } else {
                            // Create new tag
                            await apiRequest(`/tags?type=${selectedType.value}`, {
                                method: 'POST',
                                body: JSON.stringify(tagData)
                            });
                        }
                        
                        cancelEdit();
                        await loadTags();
                    } catch (error) {
                        console.error('Error saving tag:', error);
                        
                        // Parse validation errors from ChurchTools
                        if (error.message.includes('validation')) {
                            try {
                                const errorData = JSON.parse(error.message.split('HTTP 400: ')[1] || '{}');
                                if (errorData.errors && errorData.errors.length > 0) {
                                    const fieldErrors = errorData.errors.map(err => `${err.fieldId}: ${err.message}`).join(', ');
                                    tagError.value = `Validation error: ${fieldErrors}`;
                                } else {
                                    tagError.value = errorData.translatedMessage || error.message;
                                }
                            } catch (parseError) {
                                tagError.value = error.message;
                            }
                        } else {
                            tagError.value = error.message;
                        }
                    } finally {
                        isSaving.value = false;
                    }
                };
                
                const cancelEdit = () => {
                    showCreateForm.value = false;
                    editingTag.value = null;
                    tagForm.name = '';
                    tagForm.description = '';
                    tagForm.color = '';
                    tagError.value = '';
                };
                
                const deleteTag = async (tag) => {
                    if (!confirm(`Are you sure you want to delete "${tag.name}"?`)) {
                        return;
                    }
                    
                    try {
                        await apiRequest(`/tags/${tag.id}?type=${selectedType.value}`, {
                            method: 'DELETE'
                        });
                        await loadTags();
                    } catch (error) {
                        console.error('Error deleting tag:', error);
                        alert(`Failed to delete tag: ${error.message}`);
                    }
                };
                
                // Bulk Operations
                const toggleSelectAll = () => {
                    if (allSelected.value) {
                        selectedTags.value = [];
                    } else {
                        selectedTags.value = tags.value.map(tag => tag.id);
                    }
                };
                
                const toggleTagSelection = (tagId) => {
                    const index = selectedTags.value.indexOf(tagId);
                    if (index > -1) {
                        selectedTags.value.splice(index, 1);
                    } else {
                        selectedTags.value.push(tagId);
                    }
                };
                
                const selectAll = () => {
                    selectedTags.value = tags.value.map(tag => tag.id);
                };
                
                const clearSelection = () => {
                    selectedTags.value = [];
                    bulkError.value = '';
                    bulkSuccess.value = '';
                };
                
                const selectByPrefix = () => {
                    if (!prefixFilter.value.trim()) {
                        bulkError.value = 'Please enter a prefix pattern (e.g., L:*)';
                        return;
                    }
                    
                    const pattern = prefixFilter.value.trim().replace('*', '');
                    const matchingTags = tags.value.filter(tag => 
                        tag.name.toLowerCase().startsWith(pattern.toLowerCase())
                    );
                    
                    selectedTags.value = matchingTags.map(tag => tag.id);
                    bulkSuccess.value = `Selected ${matchingTags.length} tags matching "${pattern}"`;
                    bulkError.value = '';
                    
                    // Clear success message after 3 seconds
                    setTimeout(() => {
                        bulkSuccess.value = '';
                    }, 3000);
                };
                
                const applyBulkColor = async () => {
                    if (!bulkColor.value) {
                        bulkError.value = 'Please select a color';
                        return;
                    }
                    
                    if (selectedTags.value.length === 0) {
                        bulkError.value = 'Please select tags to update';
                        return;
                    }
                    
                    if (!confirm(`Apply ${bulkColor.value} color to ${selectedTags.value.length} selected tags?`)) {
                        return;
                    }
                    
                    isBulkOperating.value = true;
                    bulkError.value = '';
                    bulkSuccess.value = '';
                    
                    try {
                        const promises = selectedTags.value.map(tagId => {
                            // Find the tag to get its current name
                            const tag = tags.value.find(t => t.id === tagId);
                            if (!tag) {
                                throw new Error(`Tag with ID ${tagId} not found`);
                            }
                            
                            return apiRequest(`/tags/${tagId}?type=${selectedType.value}`, {
                                method: 'PUT',
                                body: JSON.stringify({ 
                                    name: tag.name, // Include existing name
                                    description: tag.description || '', // Include existing description
                                    color: bulkColor.value 
                                })
                            });
                        });
                        
                        await Promise.all(promises);
                        
                        bulkSuccess.value = `Successfully updated ${selectedTags.value.length} tags to ${bulkColor.value}`;
                        selectedTags.value = [];
                        bulkColor.value = '';
                        await loadTags();
                        
                        // Clear success message after 5 seconds
                        setTimeout(() => {
                            bulkSuccess.value = '';
                        }, 5000);
                        
                    } catch (error) {
                        console.error('Error applying bulk color:', error);
                        
                        // Parse ChurchTools validation errors
                        let errorMessage = error.message;
                        if (error.message.includes('validation')) {
                            try {
                                const errorData = JSON.parse(error.message.split('HTTP 400: ')[1] || '{}');
                                if (errorData.translatedMessage) {
                                    errorMessage = errorData.translatedMessage;
                                    if (errorData.errors && errorData.errors.length > 0) {
                                        const fieldErrors = errorData.errors.map(err => err.message).join(', ');
                                        errorMessage += ` Details: ${fieldErrors}`;
                                    }
                                }
                            } catch (parseError) {
                                // Keep original error message
                            }
                        }
                        
                        bulkError.value = `Failed to update tags: ${errorMessage}`;
                    } finally {
                        isBulkOperating.value = false;
                    }
                };
                
                const bulkDelete = async () => {
                    if (selectedTags.value.length === 0) {
                        bulkError.value = 'Please select tags to delete';
                        return;
                    }
                    
                    const selectedTagNames = tags.value
                        .filter(tag => selectedTags.value.includes(tag.id))
                        .map(tag => tag.name)
                        .join(', ');
                    
                    if (!confirm(`Are you sure you want to delete ${selectedTags.value.length} selected tags?\n\nTags: ${selectedTagNames}\n\nThis action cannot be undone.`)) {
                        return;
                    }
                    
                    isBulkOperating.value = true;
                    bulkError.value = '';
                    bulkSuccess.value = '';
                    
                    try {
                        const promises = selectedTags.value.map(tagId => 
                            apiRequest(`/tags/${tagId}?type=${selectedType.value}`, {
                                method: 'DELETE'
                            })
                        );
                        
                        await Promise.all(promises);
                        
                        bulkSuccess.value = `Successfully deleted ${selectedTags.value.length} tags`;
                        selectedTags.value = [];
                        await loadTags();
                        
                        // Clear success message after 5 seconds
                        setTimeout(() => {
                            bulkSuccess.value = '';
                        }, 5000);
                        
                    } catch (error) {
                        console.error('Error bulk deleting tags:', error);
                        bulkError.value = `Failed to delete tags: ${error.message}`;
                    } finally {
                        isBulkOperating.value = false;
                    }
                };
                
                // Check for stored authentication on mount
                onMounted(() => {
                    const storedToken = localStorage.getItem('ct_login_token');
                    const storedPersonId = localStorage.getItem('ct_person_id');
                    const storedBaseUrl = localStorage.getItem('ct_base_url');
                    const storedUsername = localStorage.getItem('ct_username');
                    
                    if (storedToken && storedPersonId && storedBaseUrl && storedUsername) {
                        apiToken.value = storedToken;
                        personId.value = parseInt(storedPersonId);
                        loginForm.baseUrl = storedBaseUrl;
                        currentUser.value = storedUsername;
                        isAuthenticated.value = true;
                        
                        // Load tags automatically
                        loadTags();
                    }
                });
                
                return {
                    isAuthenticated,
                    currentUser,
                    isLoading,
                    isLoadingTags,
                    isSaving,
                    loginError,
                    loginStatus,
                    tagError,
                    selectedType,
                    showCreateForm,
                    editingTag,
                    loginForm,
                    tagForm,
                    tags,
                    selectedTags,
                    prefixFilter,
                    bulkColor,
                    bulkError,
                    bulkSuccess,
                    isBulkOperating,
                    allSelected,
                    login,
                    logout,
                    loadTags,
                    editTag,
                    saveTag,
                    cancelEdit,
                    deleteTag,
                    toggleSelectAll,
                    toggleTagSelection,
                    selectAll,
                    clearSelection,
                    selectByPrefix,
                    applyBulkColor,
                    bulkDelete,
                    sortedTags,
                    sortField,
                    sortDirection,
                    sortBy: (field) => {
                        if (sortField.value === field) {
                            sortDirection.value = sortDirection.value === 'asc' ? 'desc' : 'asc';
                        } else {
                            sortField.value = field;
                            sortDirection.value = 'asc';
                        }
                    }
                };
            }
        }).mount('#app');
    </script>
</body>
</html>